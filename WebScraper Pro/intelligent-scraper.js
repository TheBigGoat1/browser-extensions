/**
 * Scrape Orange v2.1 - Intelligent Scraper
 * AI-powered extraction based on user requirements
 * Works on any website - automatically finds what user needs
 */

(function() {
  'use strict';

  // ============================================================================
  // INTELLIGENT SCRAPER CLASS
  // ============================================================================
  
  class IntelligentScraper {
    constructor() {
      this.requirements = null;
      this.autoSelectors = [];
    }

    /**
     * Analyze page and extract based on requirements
     * @param {string} requirements - User's natural language requirements
     * @returns {Promise<Object>} Generated sitemap with selectors
     */
    async analyzeAndExtract(requirements) {
      console.log('[IntelligentScraper] Analyzing page with requirements:', requirements);
      
      this.requirements = this.parseRequirements(requirements);
      
      // Analyze page structure
      const pageAnalysis = this.analyzePageStructure();
      
      // Generate selectors based on requirements
      const selectors = this.generateSelectors(pageAnalysis);
      
      // Build sitemap
      const sitemap = {
        id: `intelligent_${Date.now()}`,
        name: 'Intelligent Scrape',
        startUrl: window.location.href,
        selectors: selectors,
        autoGenerated: true,
        requirements: requirements
      };
      
      console.log('[IntelligentScraper] Generated sitemap:', sitemap);
      return sitemap;
    }

    /**
     * Parse user requirements into structured data
     */
    parseRequirements(requirements) {
      const req = requirements.toLowerCase();
      
      return {
        text: req,
        wantsText: this.hasKeyword(req, ['text', 'title', 'heading', 'content', 'description', 'name']),
        wantsLinks: this.hasKeyword(req, ['link', 'url', 'href', 'navigation', 'menu']),
        wantsImages: this.hasKeyword(req, ['image', 'photo', 'picture', 'img']),
        wantsPrices: this.hasKeyword(req, ['price', 'cost', 'amount', 'money', '$']),
        wantsLists: this.hasKeyword(req, ['list', 'items', 'products', 'articles', 'posts']),
        wantsTables: this.hasKeyword(req, ['table', 'data', 'rows', 'columns']),
        wantsAttributes: this.hasKeyword(req, ['attribute', 'class', 'id', 'data']),
        specificKeywords: this.extractKeywords(req)
      };
    }

    /**
     * Check if requirements contain keywords
     */
    hasKeyword(text, keywords) {
      return keywords.some(keyword => text.includes(keyword));
    }

    /**
     * Extract specific keywords from requirements
     */
    extractKeywords(text) {
      const common = ['product', 'article', 'post', 'item', 'card', 'heading', 'title', 'price', 'image'];
      return common.filter(keyword => text.includes(keyword));
    }

    /**
     * Analyze page structure to find extractable elements - ENHANCED with proactive filtering
     */
    analyzePageStructure() {
      const analysis = {
        headings: [],
        links: [],
        images: [],
        lists: [],
        tables: [],
        prices: [],
        containers: []
      };

      console.log('[IntelligentScraper] Analyzing page structure with proactive filtering...');

      // Find headings - FILTER CSS/NOISE PROACTIVELY
      ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(tag => {
        const elements = document.querySelectorAll(tag);
        elements.forEach(el => {
          // Proactive filtering: Skip if element looks like CSS/noise
          if (this.shouldSkipElement(el)) return;
          
          const text = el.textContent?.trim();
          if (text && text.length > 0 && !this.isCSSContent(text)) {
            // Check visibility
            const rect = el.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
              analysis.headings.push({
                element: el,
                tag: tag,
                text: text,
                selector: this.generateSelector(el),
                confidence: this.calculateConfidence(el, 'heading')
              });
            }
          }
        });
      });
      
      // Sort by confidence
      analysis.headings.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
      console.log(`[IntelligentScraper] Found ${analysis.headings.length} headings (filtered)`);

      // Find links - FILTER PROACTIVELY
      document.querySelectorAll('a[href]').forEach(link => {
        // Proactive filtering
        if (this.shouldSkipElement(link)) return;
        
        const href = link.href;
        const text = link.textContent?.trim();
        
        // Skip javascript links, anchors, and same-page links
        if (href && !href.startsWith('javascript:') && !href.startsWith('#') && 
            href !== window.location.href && text && text.length > 0) {
          // Check visibility
          const rect = link.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            analysis.links.push({
              element: link,
              href: href,
              text: text,
              selector: this.generateSelector(link),
              confidence: this.calculateConfidence(link, 'link')
            });
          }
        }
      });
      
      // Sort by confidence
      analysis.links.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
      console.log(`[IntelligentScraper] Found ${analysis.links.length} links (filtered)`);

      // Find images - FILTER PROACTIVELY
      document.querySelectorAll('img[src]').forEach(img => {
        // Proactive filtering
        if (this.shouldSkipElement(img)) return;
        
        const src = img.src;
        // Skip data URIs, placeholders, tracking pixels
        if (src && !src.includes('data:image') && !src.includes('placeholder') && 
            !src.includes('1x1') && !src.includes('pixel') && !src.includes('tracking')) {
          // Check visibility and size
          const rect = img.getBoundingClientRect();
          if (rect.width > 10 && rect.height > 10) {
            analysis.images.push({
              element: img,
              src: src,
              alt: img.alt || '',
              selector: this.generateSelector(img),
              confidence: this.calculateConfidence(img, 'image')
            });
          }
        }
      });
      
      // Sort by confidence
      analysis.images.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
      console.log(`[IntelligentScraper] Found ${analysis.images.length} images (filtered)`);

      // Find lists
      document.querySelectorAll('ul, ol').forEach(list => {
        const items = Array.from(list.querySelectorAll('li'));
        if (items.length > 0) {
          analysis.lists.push({
            element: list,
            itemCount: items.length,
            selector: this.generateSelector(list)
          });
        }
      });

      // Find tables
      document.querySelectorAll('table').forEach(table => {
        const rows = table.querySelectorAll('tr');
        if (rows.length > 0) {
          analysis.tables.push({
            element: table,
            rowCount: rows.length,
            selector: this.generateSelector(table)
          });
        }
      });

      // Find prices (common patterns)
      const pricePattern = /\$[\d,]+\.?\d*/g;
      document.querySelectorAll('*').forEach(el => {
        const text = el.textContent || '';
        if (pricePattern.test(text) && el.children.length === 0) {
          analysis.prices.push({
            element: el,
            price: text.match(pricePattern)?.[0],
            selector: this.generateSelector(el)
          });
        }
      });

      // Find container elements (common patterns) - ENHANCED with pattern recognition
      const containerSelectors = [
        'article', 'section', '.card', '.item', '.product', 
        '.post', '.entry', '[class*="item"]', '[class*="card"]'
      ];
      
      containerSelectors.forEach(sel => {
        try {
          document.querySelectorAll(sel).forEach(container => {
            // Proactive filtering
            if (this.shouldSkipElement(container)) return;
            
            if (container.children.length > 0) {
              // Check if container has meaningful content
              const textContent = container.textContent?.trim();
              if (textContent && textContent.length > 10 && !this.isCSSContent(textContent)) {
                // Calculate similarity score (how many similar containers exist)
                const similarContainers = document.querySelectorAll(sel);
                const similarityScore = similarContainers.length > 1 ? 
                  Math.min(1, 10 / similarContainers.length) : 0.5;
                
                analysis.containers.push({
                  element: container,
                  selector: sel,
                  childCount: container.children.length,
                  textLength: textContent.length,
                  confidence: similarityScore,
                  pattern: this.detectContainerPattern(container)
                });
              }
            }
          });
        } catch (e) {
          // Invalid selector, skip
        }
      });
      
      // Sort containers by confidence and pattern match
      analysis.containers.sort((a, b) => {
        const scoreA = (a.confidence || 0) + (a.pattern ? 0.3 : 0);
        const scoreB = (b.confidence || 0) + (b.pattern ? 0.3 : 0);
        return scoreB - scoreA;
      });
      
      console.log(`[IntelligentScraper] Found ${analysis.containers.length} containers (filtered and scored)`);

      return analysis;
    }
    
    /**
     * Check if element should be skipped (proactive filtering)
     */
    shouldSkipElement(element) {
      if (!element) return true;
      
      // Skip hidden elements
      const style = window.getComputedStyle(element);
      if (style.display === 'none' || style.visibility === 'hidden' || 
          style.opacity === '0' || style.width === '0px' || style.height === '0px') {
        return true;
      }
      
      // Skip elements with CSS-like class names
      const className = element.className;
      if (typeof className === 'string') {
        const cssPatterns = [
          /^_[a-zA-Z0-9_-]+$/,
          /style_/,
          /cropped-image-link/,
          /^[a-z]+-[a-z]+-[a-z]+-[a-z]+-[a-z]+/ // Very long class names (CSS modules)
        ];
        
        if (cssPatterns.some(pattern => pattern.test(className))) {
          return true;
        }
      }
      
      // Skip script, style, noscript tags
      if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'SVG', 'PATH'].includes(element.tagName)) {
        return true;
      }
      
      // Skip elements in common noise areas
      const parent = element.closest('nav, footer, header, aside, .sidebar, .menu, .navigation');
      if (parent && !parent.closest('main, article, section[class*="content"]')) {
        return true;
      }
      
      return false;
    }
    
    /**
     * Calculate confidence score for element
     */
    calculateConfidence(element, type) {
      let score = 0.5; // Base score
      
      // ID selector is most specific
      if (element.id) score += 0.3;
      
      // Class selector
      if (element.className && typeof element.className === 'string') {
        const classes = element.className.trim().split(/\s+/).filter(c => c);
        if (classes.length > 0 && classes.length < 5) {
          score += 0.2;
        }
      }
      
      // Visibility check
      const rect = element.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        score += 0.2;
      }
      
      // Content quality
      const text = element.textContent?.trim();
      if (text) {
        if (text.length > 10 && text.length < 500) score += 0.1;
        if (!this.isCSSContent(text)) score += 0.2;
      }
      
      // Type-specific scoring
      if (type === 'heading' && ['H1', 'H2', 'H3'].includes(element.tagName)) {
        score += 0.1;
      }
      
      if (type === 'link' && element.href && !element.href.startsWith('javascript:')) {
        score += 0.1;
      }
      
      return Math.min(1, score);
    }
    
    /**
     * Detect container pattern (product card, article, etc.)
     */
    detectContainerPattern(container) {
      const className = container.className?.toLowerCase() || '';
      const text = container.textContent?.toLowerCase() || '';
      
      // Product patterns
      if (className.includes('product') || className.includes('item') || 
          text.includes('$') || text.includes('price') || text.includes('add to cart')) {
        return 'product';
      }
      
      // Article patterns
      if (className.includes('article') || className.includes('post') || 
          className.includes('entry') || container.tagName === 'ARTICLE') {
        return 'article';
      }
      
      // Card patterns
      if (className.includes('card')) {
        return 'card';
      }
      
      return null;
    }

    /**
     * Generate selectors based on requirements and page analysis - ENHANCED with smart optimization
     */
    generateSelectors(analysis) {
      const selectors = [];
      const req = this.requirements;

      // If user wants lists/items, find containers first - USE BEST CONTAINER
      if (req.wantsLists && analysis.containers.length > 0) {
        // Use container with highest confidence and best pattern match
        const container = analysis.containers[0];
        
        // Generate optimized selector (more specific)
        const optimizedSelector = this.optimizeSelector(container.selector, container.element);
        
        selectors.push({
          id: 'container',
          type: 'SelectorElement',
          parentSelectors: ['_root'],
          selector: optimizedSelector,
          originalSelector: container.selector,
          multiple: true,
          confidence: container.confidence,
          pattern: container.pattern,
          fallbacks: this.generateFallbackSelectors(container.element)
        });

        // Add child selectors - USE SMART SELECTORS
        if (req.wantsText) {
          // Find best title selector within container pattern
          const titleSelector = this.findBestTitleSelector(container.element, container.pattern);
          
          selectors.push({
            id: 'title',
            type: 'SelectorText',
            parentSelectors: ['container'],
            selector: titleSelector,
            multiple: false,
            fallbacks: ['h1', 'h2', 'h3', '.title', '[class*="title"]']
          });
        }

        if (req.wantsLinks) {
          selectors.push({
            id: 'link',
            type: 'SelectorLink',
            parentSelectors: ['container'],
            selector: 'a',
            multiple: false
          });
        }

        if (req.wantsImages) {
          selectors.push({
            id: 'image',
            type: 'SelectorImage',
            parentSelectors: ['container'],
            selector: 'img',
            multiple: false
          });
        }

        if (req.wantsPrices) {
          selectors.push({
            id: 'price',
            type: 'SelectorText',
            parentSelectors: ['container'],
            selector: '[class*="price"], [class*="cost"], .price',
            multiple: false
          });
        }
      } else {
        // Extract individual elements
        if (req.wantsText && analysis.headings.length > 0) {
          const heading = analysis.headings[0];
          selectors.push({
            id: 'heading',
            type: 'SelectorText',
            parentSelectors: ['_root'],
            selector: heading.selector,
            multiple: analysis.headings.length > 1
          });
        }

        if (req.wantsLinks && analysis.links.length > 0) {
          const link = analysis.links[0];
          selectors.push({
            id: 'link',
            type: 'SelectorLink',
            parentSelectors: ['_root'],
            selector: link.selector,
            multiple: analysis.links.length > 1
          });
        }

        if (req.wantsImages && analysis.images.length > 0) {
          const image = analysis.images[0];
          selectors.push({
            id: 'image',
            type: 'SelectorImage',
            parentSelectors: ['_root'],
            selector: image.selector,
            multiple: analysis.images.length > 1
          });
        }

        if (req.wantsTables && analysis.tables.length > 0) {
          const table = analysis.tables[0];
          selectors.push({
            id: 'table',
            type: 'SelectorTable',
            parentSelectors: ['_root'],
            selector: table.selector,
            multiple: false
          });
        }
      }

      // If no selectors generated, create a generic text extractor with fallbacks
      if (selectors.length === 0) {
        // Try to find any meaningful content
        const bestHeading = analysis.headings[0];
        const bestLink = analysis.links[0];
        
        if (bestHeading) {
          selectors.push({
            id: 'content',
            type: 'SelectorText',
            parentSelectors: ['_root'],
            selector: bestHeading.selector,
            multiple: analysis.headings.length > 1,
            confidence: bestHeading.confidence,
            fallbacks: ['h1', 'h2', 'p', 'body']
          });
        } else {
          selectors.push({
            id: 'content',
            type: 'SelectorText',
            parentSelectors: ['_root'],
            selector: 'body',
            multiple: false,
            fallbacks: ['main', 'article', 'section', 'p']
          });
        }
      }

      console.log(`[IntelligentScraper] Generated ${selectors.length} optimized selectors`);
      return selectors;
    }
    
    /**
     * Optimize selector to be more specific
     */
    optimizeSelector(originalSelector, element) {
      // If element has ID, use it
      if (element.id) {
        return `#${element.id}`;
      }
      
      // If element has specific class, use it
      if (element.className && typeof element.className === 'string') {
        const classes = element.className.trim().split(/\s+/).filter(c => c && !c.startsWith('_'));
        if (classes.length > 0 && classes.length <= 3) {
          // Use most specific class
          const specificClass = classes.find(c => 
            document.querySelectorAll(`.${c}`).length <= 20
          ) || classes[0];
          
          return `${element.tagName.toLowerCase()}.${specificClass}`;
        }
      }
      
      // Try to find unique parent path
      const path = [];
      let current = element;
      let depth = 0;
      
      while (current && current !== document.body && depth < 3) {
        let selector = current.tagName.toLowerCase();
        if (current.className && typeof current.className === 'string') {
          const classes = current.className.trim().split(/\s+/).filter(c => c);
          if (classes.length > 0 && classes.length <= 2) {
            selector += '.' + classes[0];
          }
        }
        path.unshift(selector);
        current = current.parentElement;
        depth++;
      }
      
      if (path.length > 1) {
        return path.join(' > ');
      }
      
      return originalSelector;
    }
    
    /**
     * Generate fallback selectors
     */
    generateFallbackSelectors(element) {
      const fallbacks = [];
      
      // Try parent element
      if (element.parentElement) {
        const parentSel = this.generateSelector(element.parentElement);
        if (parentSel && parentSel !== 'body') {
          fallbacks.push(parentSel);
        }
      }
      
      // Try similar class patterns
      if (element.className && typeof element.className === 'string') {
        const classes = element.className.trim().split(/\s+/).filter(c => c);
        classes.forEach(cls => {
          if (!cls.startsWith('_')) {
            fallbacks.push(`.${cls}`);
          }
        });
      }
      
      // Try tag name
      fallbacks.push(element.tagName.toLowerCase());
      
      return fallbacks.slice(0, 3); // Max 3 fallbacks
    }
    
    /**
     * Find best title selector within container
     */
    findBestTitleSelector(container, pattern) {
      // Try to find title within container
      const titleCandidates = container.querySelectorAll('h1, h2, h3, h4, [class*="title"], [class*="name"]');
      
      if (titleCandidates.length > 0) {
        // Find most common selector
        const selectorCounts = {};
        titleCandidates.forEach(el => {
          const sel = this.generateSelector(el);
          selectorCounts[sel] = (selectorCounts[sel] || 0) + 1;
        });
        
        const bestSelector = Object.entries(selectorCounts)
          .sort((a, b) => b[1] - a[1])[0]?.[0];
        
        if (bestSelector) {
          return bestSelector;
        }
      }
      
      // Pattern-specific defaults
      if (pattern === 'product') {
        return 'h2, h3, [class*="product-title"], [class*="item-title"]';
      }
      
      if (pattern === 'article') {
        return 'h1, h2, [class*="article-title"], [class*="post-title"]';
      }
      
      // Generic fallback
      return 'h1, h2, h3, .title, [class*="title"]';
    }

    /**
     * Generate optimal CSS selector for element
     */
    generateSelector(element) {
      // Try ID first
      if (element.id) {
        return `#${element.id}`;
      }

      // Try class
      if (element.className && typeof element.className === 'string') {
        const classes = element.className.trim().split(/\s+/).filter(c => c);
        if (classes.length > 0) {
          const classSelector = `${element.tagName.toLowerCase()}.${classes[0]}`;
          const matches = document.querySelectorAll(classSelector);
          if (matches.length === 1) {
            return classSelector;
          }
        }
      }

      // Try tag name
      const tagSelector = element.tagName.toLowerCase();
      const tagMatches = document.querySelectorAll(tagSelector);
      if (tagMatches.length <= 5) {
        return tagSelector;
      }

      // Fallback to path
      const path = [];
      let current = element;
      while (current && current !== document.body) {
        let selector = current.tagName.toLowerCase();
        if (current.className && typeof current.className === 'string') {
          const classes = current.className.trim().split(/\s+/).filter(c => c);
          if (classes.length > 0) {
            selector += '.' + classes[0];
          }
        }
        path.unshift(selector);
        current = current.parentElement;
        if (path.length > 3) break; // Limit path depth
      }
      return path.join(' > ');
    }

    /**
     * Execute intelligent scraping - ACTUALLY EXTRACT DATA
     */
    async execute(requirements) {
      const sitemap = await this.analyzeAndExtract(requirements);
      
      console.log('[IntelligentScraper] Generated sitemap:', sitemap);
      console.log('[IntelligentScraper] Starting data extraction...');
      
      // Extract data directly using the selectors
      const results = [];
      
      for (const selector of sitemap.selectors) {
        try {
          // Find elements matching selector
          const elements = document.querySelectorAll(selector.selector);
          console.log(`[IntelligentScraper] Found ${elements.length} elements for selector: ${selector.id} (${selector.selector})`);
          
          if (elements.length === 0) {
            console.warn(`[IntelligentScraper] No elements found for selector: ${selector.selector}`);
            continue;
          }
          
          // Extract data based on type
          if (selector.type === 'SelectorElement' && selector.multiple) {
            // Container selector - extract child data for each container
            elements.forEach((container, index) => {
              const itemData = { _index: index };
              
              // Find child selectors
              const childSelectors = sitemap.selectors.filter(s => 
                s.parentSelectors.includes(selector.id)
              );
              
              childSelectors.forEach(childSel => {
                const childElements = container.querySelectorAll(childSel.selector);
                if (childElements.length > 0) {
                  const childData = Array.from(childElements)
                    .map(el => {
                      if (childSel.type === 'SelectorText') {
                        return this.cleanText(el.textContent?.trim() || '');
                      } else if (childSel.type === 'SelectorLink') {
                        return el.href || el.getAttribute('href') || '';
                      } else if (childSel.type === 'SelectorImage') {
                        return el.src || el.getAttribute('src') || '';
                      }
                      return this.cleanText(el.textContent?.trim() || '');
                    })
                    .filter(text => text && text.length > 0 && !this.isCSSContent(text));
                  
                  itemData[childSel.id] = childSel.multiple ? childData : (childData[0] || '');
                }
              });
              
              if (Object.keys(itemData).length > 1) { // More than just _index
                results.push(itemData);
              }
            });
          } else {
            // Direct extraction - clean and filter
            const extracted = Array.from(elements)
              .map(el => {
                if (selector.type === 'SelectorText') {
                  return this.cleanText(el.textContent?.trim() || '');
                } else if (selector.type === 'SelectorLink') {
                  return el.href || el.getAttribute('href') || '';
                } else if (selector.type === 'SelectorImage') {
                  return el.src || el.getAttribute('src') || '';
                }
                return this.cleanText(el.textContent?.trim() || '');
              })
              .filter(text => text && text.length > 0 && !this.isCSSContent(text));
            
            if (selector.multiple) {
              extracted.forEach((value, index) => {
                results.push({ [selector.id]: value, _index: index });
              });
            } else {
              if (extracted.length > 0) {
                results.push({ [selector.id]: extracted[0] });
              }
            }
          }
        } catch (error) {
          console.error(`[IntelligentScraper] Error extracting ${selector.id}:`, error);
        }
      }
      
      console.log('[IntelligentScraper] Extracted results:', results.length, results);
      
      // If no results, try fallback extraction
      if (results.length === 0) {
        console.log('[IntelligentScraper] No results, trying fallback extraction...');
        results.push(...this.fallbackExtraction(requirements));
      }
      
      return {
        sitemap: sitemap,
        results: results
      };
    }
    
    /**
     * Fallback extraction when selectors don't match
     */
    fallbackExtraction(requirements) {
      const results = [];
      const req = requirements.toLowerCase();
      
      // Try to find common content patterns
      const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
      if (headings.length > 0 && (req.includes('heading') || req.includes('title') || req.includes('text'))) {
        Array.from(headings).forEach((h, i) => {
          const text = h.textContent?.trim();
          if (text) {
            results.push({ heading: text, level: h.tagName, index: i });
          }
        });
      }
      
      // Try to find paragraphs
      const paragraphs = document.querySelectorAll('p');
      if (paragraphs.length > 0 && req.includes('text')) {
        Array.from(paragraphs).slice(0, 10).forEach((p, i) => {
          const text = p.textContent?.trim();
          if (text && text.length > 20) {
            results.push({ text: text, index: i });
          }
        });
      }
      
      // Try to find links
      const links = document.querySelectorAll('a[href]');
      if (links.length > 0 && req.includes('link')) {
        Array.from(links).slice(0, 20).forEach((a, i) => {
          const href = a.href;
          const text = a.textContent?.trim();
          if (href) {
            results.push({ link: href, linkText: text, index: i });
          }
        });
      }
      
      // Try to find images
      const images = document.querySelectorAll('img[src]');
      if (images.length > 0 && req.includes('image')) {
        Array.from(images).slice(0, 20).forEach((img, i) => {
          const src = img.src;
          const alt = img.alt || '';
          if (src) {
            results.push({ image: src, alt: alt, index: i });
          }
        });
      }
      
      // Try to find list items
      const listItems = document.querySelectorAll('li');
      if (listItems.length > 0 && req.includes('list')) {
        Array.from(listItems).slice(0, 50).forEach((li, i) => {
          const text = li.textContent?.trim();
          if (text) {
            results.push({ listItem: text, index: i });
          }
        });
      }
      
      console.log('[IntelligentScraper] Fallback extraction found:', results.length, 'items');
      return results;
    }
    
    /**
     * Clean text content - remove CSS, scripts, and noise
     */
    cleanText(text) {
      if (!text || typeof text !== 'string') return '';
      
      // Remove CSS content
      if (this.isCSSContent(text)) return '';
      
      // Remove excessive whitespace
      text = text.replace(/\s+/g, ' ').trim();
      
      // Remove very short or meaningless text
      if (text.length < 2) return '';
      
      return text;
    }
    
    /**
     * Check if content is CSS/style code
     */
    isCSSContent(text) {
      if (!text || typeof text !== 'string') return false;
      
      const cssPatterns = [
        /^\._[a-zA-Z0-9_-]+{/,
        /@media\s*\(/,
        /background-color:/,
        /border-radius:/,
        /display:\s*-webkit-box/,
        /\.cropped-image-link/,
        /\._cropped-image-link/,
        /function\([^)]*\)\s*\{/,
        /\.style_/,
        /padding:\s*\d+px/,
        /margin:\s*\d+px/,
        /font-size:\s*\d+px/,
        /color:\s*#[0-9a-fA-F]{3,6}/,
        /-webkit-box-orient:/,
        /-ms-flex:/,
        /object-fit:/,
        /position:\s*(absolute|relative|fixed)/
      ];
      
      // If text is very long and contains many CSS patterns, it's likely CSS
      if (text.length > 500) {
        const cssMatches = cssPatterns.filter(pattern => pattern.test(text)).length;
        if (cssMatches > 3) return true;
      }
      
      // Check for specific CSS patterns
      return cssPatterns.some(pattern => pattern.test(text));
    }
  }

  // ============================================================================
  // EXPORT
  // ============================================================================
  
  window.IntelligentScraper = IntelligentScraper;

  console.log('[IntelligentScraper] Module loaded');

})();
